{"mappings":"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","sources":["src/linewrap.js","src/canvas-dither.js","src/canvas-flatten.js","src/codepage-encoder.js","src/canvas.js","src/escposencoder.js"],"sourcesContent":["// Presets\nvar presetMap = {\n  html: {\n    skipScheme: \"html\",\n    lineBreakScheme: \"html\",\n    whitespace: \"collapse\",\n  },\n};\n\n// lineBreak Schemes\nvar brPat = /<\\s*br(?:[\\s/]*|\\s[^>]*)>/gi;\nvar lineBreakSchemeMap = {\n  unix: [/\\n/g, \"\\n\"],\n  dos: [/\\r\\n/g, \"\\r\\n\"],\n  mac: [/\\r/g, \"\\r\"],\n  html: [brPat, \"<br>\"],\n  xhtml: [brPat, \"<br/>\"],\n};\n\n// skip Schemes\nvar skipSchemeMap = {\n  \"ansi-color\": /\\x1B\\[[^m]*m/g,\n  html: /<[^>]*>/g,\n  bbcode: /\\[[^]]*\\]/g,\n};\n\nvar modeMap = {\n  soft: 1,\n  hard: 1,\n};\n\nvar wsMap = {\n  collapse: 1,\n  default: 1,\n  line: 1,\n  all: 1,\n};\n\nvar rlbMap = {\n  all: 1,\n  multi: 1,\n  none: 1,\n};\nvar rlbSMPat = /([sm])(\\d+)/;\n\nvar escapePat = /[-/\\\\^$*+?.()|[\\]{}]/g;\nfunction escapeRegExp(s) {\n  return s.replace(escapePat, \"\\\\$&\");\n}\n\nvar linewrap = function (start, stop, params) {\n  if (typeof start === \"object\") {\n    params = start;\n    start = params.start;\n    stop = params.stop;\n  }\n\n  if (typeof stop === \"object\") {\n    params = stop;\n    start = start || params.start;\n    stop = undefined;\n  }\n\n  if (!stop) {\n    stop = start;\n    start = 0;\n  }\n\n  if (!params) {\n    params = {};\n  }\n  // Supported options and default values.\n  var preset,\n    mode = \"soft\",\n    whitespace = \"default\",\n    tabWidth = 4,\n    skip,\n    skipScheme,\n    lineBreak,\n    lineBreakScheme,\n    respectLineBreaks = \"all\",\n    respectNum,\n    preservedLineIndent,\n    wrapLineIndent,\n    wrapLineIndentBase;\n\n  var skipPat;\n  var lineBreakPat, lineBreakStr;\n  var multiLineBreakPat;\n  var preservedLinePrefix = \"\";\n  var wrapLineIndentPat,\n    wrapLineInitPrefix = \"\";\n  var tabRepl;\n  var item, flags;\n  var i;\n\n  // First process presets, because these settings can be overwritten later.\n  preset = params.preset;\n  if (preset) {\n    if (!(preset instanceof Array)) {\n      preset = [preset];\n    }\n    for (i = 0; i < preset.length; i++) {\n      item = presetMap[preset[i]];\n      if (item) {\n        if (item.mode) {\n          mode = item.mode;\n        }\n        if (item.whitespace) {\n          whitespace = item.whitespace;\n        }\n        if (item.tabWidth !== undefined) {\n          tabWidth = item.tabWidth;\n        }\n        if (item.skip) {\n          skip = item.skip;\n        }\n        if (item.skipScheme) {\n          skipScheme = item.skipScheme;\n        }\n        if (item.lineBreak) {\n          lineBreak = item.lineBreak;\n        }\n        if (item.lineBreakScheme) {\n          lineBreakScheme = item.lineBreakScheme;\n        }\n        if (item.respectLineBreaks) {\n          respectLineBreaks = item.respectLineBreaks;\n        }\n        if (item.preservedLineIndent !== undefined) {\n          preservedLineIndent = item.preservedLineIndent;\n        }\n        if (item.wrapLineIndent !== undefined) {\n          wrapLineIndent = item.wrapLineIndent;\n        }\n        if (item.wrapLineIndentBase) {\n          wrapLineIndentBase = item.wrapLineIndentBase;\n        }\n      } else {\n        throw new TypeError(\n          'preset must be one of \"' + Object.keys(presetMap).join('\", \"') + '\"'\n        );\n      }\n    }\n  }\n\n  if (params.mode) {\n    if (modeMap[params.mode]) {\n      mode = params.mode;\n    } else {\n      throw new TypeError(\n        'mode must be one of \"' + Object.keys(modeMap).join('\", \"') + '\"'\n      );\n    }\n  }\n  // Available options: 'collapse', 'default', 'line', and 'all'\n  if (params.whitespace) {\n    if (wsMap[params.whitespace]) {\n      whitespace = params.whitespace;\n    } else {\n      throw new TypeError(\n        'whitespace must be one of \"' + Object.keys(wsMap).join('\", \"') + '\"'\n      );\n    }\n  }\n\n  if (params.tabWidth !== undefined) {\n    if (parseInt(params.tabWidth, 10) >= 0) {\n      tabWidth = parseInt(params.tabWidth, 10);\n    } else {\n      throw new TypeError(\"tabWidth must be a non-negative integer\");\n    }\n  }\n  tabRepl = new Array(tabWidth + 1).join(\" \");\n\n  // Available options: 'all', 'multi', 'm\\d+', 's\\d+', 'none'\n  if (params.respectLineBreaks) {\n    if (\n      rlbMap[params.respectLineBreaks] ||\n      rlbSMPat.test(params.respectLineBreaks)\n    ) {\n      respectLineBreaks = params.respectLineBreaks;\n    } else {\n      throw new TypeError(\n        'respectLineBreaks must be one of \"' +\n        Object.keys(rlbMap).join('\", \"') +\n        '\", \"m<num>\", \"s<num>\"'\n      );\n    }\n  }\n  // After these conversions, now we have 4 options in `respectLineBreaks`:\n  // 'all', 'none', 'm' and 's'.\n  // `respectNum` is applicable iff `respectLineBreaks` is either 'm' or 's'.\n  if (respectLineBreaks === \"multi\") {\n    respectLineBreaks = \"m\";\n    respectNum = 2;\n  } else if (!rlbMap[respectLineBreaks]) {\n    var match = rlbSMPat.exec(respectLineBreaks);\n    respectLineBreaks = match[1];\n    respectNum = parseInt(match[2], 10);\n  }\n\n  if (params.preservedLineIndent !== undefined) {\n    if (parseInt(params.preservedLineIndent, 10) >= 0) {\n      preservedLineIndent = parseInt(params.preservedLineIndent, 10);\n    } else {\n      throw new TypeError(\"preservedLineIndent must be a non-negative integer\");\n    }\n  }\n\n  if (preservedLineIndent > 0) {\n    preservedLinePrefix = new Array(preservedLineIndent + 1).join(\" \");\n  }\n\n  if (params.wrapLineIndent !== undefined) {\n    if (!isNaN(parseInt(params.wrapLineIndent, 10))) {\n      wrapLineIndent = parseInt(params.wrapLineIndent, 10);\n    } else {\n      throw new TypeError(\"wrapLineIndent must be an integer\");\n    }\n  }\n  if (params.wrapLineIndentBase) {\n    wrapLineIndentBase = params.wrapLineIndentBase;\n  }\n\n  if (wrapLineIndentBase) {\n    if (wrapLineIndent === undefined) {\n      throw new TypeError(\n        \"wrapLineIndent must be specified when wrapLineIndentBase is specified\"\n      );\n    }\n    if (wrapLineIndentBase instanceof RegExp) {\n      wrapLineIndentPat = wrapLineIndentBase;\n    } else if (typeof wrapLineIndentBase === \"string\") {\n      wrapLineIndentPat = new RegExp(escapeRegExp(wrapLineIndentBase));\n    } else {\n      throw new TypeError(\n        \"wrapLineIndentBase must be either a RegExp object or a string\"\n      );\n    }\n  } else if (wrapLineIndent > 0) {\n    wrapLineInitPrefix = new Array(wrapLineIndent + 1).join(\" \");\n  } else if (wrapLineIndent < 0) {\n    throw new TypeError(\n      \"wrapLineIndent must be non-negative when a base is not specified\"\n    );\n  }\n\n  // NOTE: For the two RegExps `skipPat` and `lineBreakPat` that can be specified\n  //       by the user:\n  //       1. We require them to be \"global\", so we have to convert them to global\n  //          if the user specifies a non-global regex.\n  //       2. We cannot call `split()` on them, because they may or may not contain\n  //          capturing parentheses which affect the output of `split()`.\n\n  // Precedence: Regex = Str > Scheme\n  if (params.skipScheme) {\n    if (skipSchemeMap[params.skipScheme]) {\n      skipScheme = params.skipScheme;\n    } else {\n      throw new TypeError(\n        'skipScheme must be one of \"' +\n        Object.keys(skipSchemeMap).join('\", \"') +\n        '\"'\n      );\n    }\n  }\n  if (params.skip) {\n    skip = params.skip;\n  }\n\n  if (skip) {\n    if (skip instanceof RegExp) {\n      skipPat = skip;\n      if (!skipPat.global) {\n        flags = \"g\";\n        if (skipPat.ignoreCase) {\n          flags += \"i\";\n        }\n        if (skipPat.multiline) {\n          flags += \"m\";\n        }\n        skipPat = new RegExp(skipPat.source, flags);\n      }\n    } else if (typeof skip === \"string\") {\n      skipPat = new RegExp(escapeRegExp(skip), \"g\");\n    } else {\n      throw new TypeError(\"skip must be either a RegExp object or a string\");\n    }\n  }\n  if (!skipPat && skipScheme) {\n    skipPat = skipSchemeMap[skipScheme];\n  }\n\n  // Precedence:\n  // - for lineBreakPat: Regex > Scheme > Str\n  // - for lineBreakStr: Str > Scheme > Regex\n  if (params.lineBreakScheme) {\n    if (lineBreakSchemeMap[params.lineBreakScheme]) {\n      lineBreakScheme = params.lineBreakScheme;\n    } else {\n      throw new TypeError(\n        'lineBreakScheme must be one of \"' +\n        Object.keys(lineBreakSchemeMap).join('\", \"') +\n        '\"'\n      );\n    }\n  }\n  if (params.lineBreak) {\n    lineBreak = params.lineBreak;\n  }\n\n  if (lineBreakScheme) {\n    // Supported schemes: 'unix', 'dos', 'mac', 'html', 'xhtml'\n    item = lineBreakSchemeMap[lineBreakScheme];\n    if (item) {\n      lineBreakPat = item[0];\n      lineBreakStr = item[1];\n    }\n  }\n  if (lineBreak) {\n    if (lineBreak instanceof Array) {\n      if (lineBreak.length === 1) {\n        lineBreak = lineBreak[0];\n      } else if (lineBreak.length >= 2) {\n        if (lineBreak[0] instanceof RegExp) {\n          lineBreakPat = lineBreak[0];\n          if (typeof lineBreak[1] === \"string\") {\n            lineBreakStr = lineBreak[1];\n          }\n        } else if (lineBreak[1] instanceof RegExp) {\n          lineBreakPat = lineBreak[1];\n          if (typeof lineBreak[0] === \"string\") {\n            lineBreakStr = lineBreak[0];\n          }\n        } else if (\n          typeof lineBreak[0] === \"string\" &&\n          typeof lineBreak[1] === \"string\"\n        ) {\n          lineBreakPat = new RegExp(escapeRegExp(lineBreak[0]), \"g\");\n          lineBreakStr = lineBreak[1];\n        } else {\n          lineBreak = lineBreak[0];\n        }\n      }\n    }\n    if (typeof lineBreak === \"string\") {\n      lineBreakStr = lineBreak;\n      if (!lineBreakPat) {\n        lineBreakPat = new RegExp(escapeRegExp(lineBreak), \"g\");\n      }\n    } else if (lineBreak instanceof RegExp) {\n      lineBreakPat = lineBreak;\n    } else if (!(lineBreak instanceof Array)) {\n      throw new TypeError(\n        \"lineBreak must be a RegExp object, a string, or an array consisted of a RegExp object and a string\"\n      );\n    }\n  }\n  // Only assign defaults when `lineBreakPat` is not assigned.\n  // So if `params.lineBreak` is a RegExp, we don't have a value in `lineBreakStr`\n  // yet. We will try to get the value from the input string, and if failed, we\n  // will throw an exception.\n  if (!lineBreakPat) {\n    lineBreakPat = /\\n/g;\n    lineBreakStr = \"\\n\";\n  }\n\n  // Create `multiLineBreakPat` based on `lineBreakPat`, that matches strings\n  // consisted of one or more line breaks and zero or more whitespaces.\n  // Also convert `lineBreakPat` to global if not already so.\n  flags = \"g\";\n  if (lineBreakPat.ignoreCase) {\n    flags += \"i\";\n  }\n  if (lineBreakPat.multiline) {\n    flags += \"m\";\n  }\n  multiLineBreakPat = new RegExp(\n    \"\\\\s*(?:\" + lineBreakPat.source + \")(?:\" + lineBreakPat.source + \"|\\\\s)*\",\n    flags\n  );\n  if (!lineBreakPat.global) {\n    lineBreakPat = new RegExp(lineBreakPat.source, flags);\n  }\n\n  // Initialize other useful variables.\n  var re = mode === \"hard\" ? /\\b/ : /(\\S+\\s+)/;\n  var prefix = new Array(start + 1).join(\" \");\n  var wsStrip = whitespace === \"default\" || whitespace === \"collapse\",\n    wsCollapse = whitespace === \"collapse\",\n    wsLine = whitespace === \"line\",\n    wsAll = whitespace === \"all\";\n  var tabPat = /\\t/g,\n    collapsePat = /  +/g,\n    pPat = /^\\s+/,\n    tPat = /\\s+$/,\n    nonWsPat = /\\S/,\n    wsPat = /\\s/;\n  var wrapLen = stop - start;\n\n  return function (text) {\n    text = text.toString().replace(tabPat, tabRepl);\n\n    var match;\n    if (!lineBreakStr) {\n      // Try to get lineBreakStr from `text`\n      lineBreakPat.lastIndex = 0;\n      match = lineBreakPat.exec(text);\n      if (match) {\n        lineBreakStr = match[0];\n      } else {\n        throw new TypeError(\"Line break string for the output not specified\");\n      }\n    }\n\n    // text -> blocks; each bloc -> segments; each segment -> chunks\n    var blocks,\n      base = 0;\n    var mo, arr, b, res;\n    // Split `text` by line breaks.\n    blocks = [];\n    multiLineBreakPat.lastIndex = 0;\n    match = multiLineBreakPat.exec(text);\n    while (match) {\n      blocks.push(text.substring(base, match.index));\n\n      if (respectLineBreaks !== \"none\") {\n        arr = [];\n        b = 0;\n        lineBreakPat.lastIndex = 0;\n        mo = lineBreakPat.exec(match[0]);\n        while (mo) {\n          arr.push(match[0].substring(b, mo.index));\n          b = mo.index + mo[0].length;\n          mo = lineBreakPat.exec(match[0]);\n        }\n        arr.push(match[0].substring(b));\n        blocks.push({ type: \"break\", breaks: arr });\n      } else {\n        // Strip line breaks and insert spaces when necessary.\n        if (wsCollapse) {\n          res = \" \";\n        } else {\n          res = match[0].replace(lineBreakPat, \"\");\n        }\n        blocks.push({ type: \"break\", remaining: res });\n      }\n\n      base = match.index + match[0].length;\n      match = multiLineBreakPat.exec(text);\n    }\n    blocks.push(text.substring(base));\n\n    var i, j, k;\n    var segments;\n    if (skipPat) {\n      segments = [];\n      for (i = 0; i < blocks.length; i++) {\n        var bloc = blocks[i];\n        if (typeof bloc !== \"string\") {\n          // This is an object.\n          segments.push(bloc);\n        } else {\n          base = 0;\n          skipPat.lastIndex = 0;\n          match = skipPat.exec(bloc);\n          while (match) {\n            segments.push(bloc.substring(base, match.index));\n            segments.push({ type: \"skip\", value: match[0] });\n            base = match.index + match[0].length;\n            match = skipPat.exec(bloc);\n          }\n          segments.push(bloc.substring(base));\n        }\n      }\n    } else {\n      segments = blocks;\n    }\n\n    var chunks = [];\n    for (i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n      if (typeof segment !== \"string\") {\n        // This is an object.\n        chunks.push(segment);\n      } else {\n        if (wsCollapse) {\n          segment = segment.replace(collapsePat, \" \");\n        }\n\n        var parts = segment.split(re),\n          acc = [];\n\n        for (j = 0; j < parts.length; j++) {\n          var x = parts[j];\n          if (mode === \"hard\") {\n            for (k = 0; k < x.length; k += wrapLen) {\n              acc.push(x.slice(k, k + wrapLen));\n            }\n          } else {\n            acc.push(x);\n          }\n        }\n        chunks = chunks.concat(acc);\n      }\n    }\n\n    var curLine = 0,\n      curLineLength = start + preservedLinePrefix.length,\n      lines = [prefix + preservedLinePrefix],\n      // Holds the \"real length\" (excluding trailing whitespaces) of the\n      // current line if it exceeds `stop`, otherwise 0.\n      // ONLY USED when `wsAll` is true, in `finishOffCurLine()`.\n      bulge = 0,\n      // `cleanLine` is true iff we are at the beginning of an output line. By\n      // \"beginning\" we mean it doesn't contain any non-whitespace char yet.\n      // But its `curLineLength` can be greater than `start`, or even possibly\n      // be greater than `stop`, if `wsStrip` is false.\n      //\n      // Note that a \"clean\" line can still contain skip strings, in addition\n      // to whitespaces.\n      //\n      // This variable is used to allow us strip preceding whitespaces when\n      // `wsStrip` is true, or `wsLine` is true and `preservedLine` is false.\n      cleanLine = true,\n      // `preservedLine` is true iff we are in a preserved input line.\n      //\n      // It's used when `wsLine` is true to (combined with `cleanLine`) decide\n      // whether a whitespace is at the beginning of a preserved input line and\n      // should not be stripped.\n      preservedLine = true,\n      // The current indent prefix for wrapped lines.\n      wrapLinePrefix = wrapLineInitPrefix,\n      remnant;\n\n    // Always returns '' if `beforeHardBreak` is true.\n    //\n    // Assumption: Each call of this function is always followed by a `lines.push()` call.\n    //\n    // This function can change the status of `cleanLine`, but we don't modify the value of\n    // `cleanLine` in this function. It's fine because `cleanLine` will be set to the correct\n    // value after the `lines.push()` call following this function call. We also don't update\n    // `curLineLength` when pushing a new line and it's safe for the same reason.\n    function finishOffCurLine(beforeHardBreak) {\n      var str = lines[curLine],\n        idx,\n        ln,\n        rBase;\n\n      if (!wsAll) {\n        // Strip all trailing whitespaces past `start`.\n        idx = str.length - 1;\n        while (idx >= start && str[idx] === \" \") {\n          idx--;\n        }\n        while (idx >= start && wsPat.test(str[idx])) {\n          idx--;\n        }\n        idx++;\n\n        if (idx !== str.length) {\n          lines[curLine] = str.substring(0, idx);\n        }\n\n        if (preservedLine && cleanLine && wsLine && curLineLength > stop) {\n          // Add the remnants to the next line, just like when `wsAll` is true.\n          rBase = str.length - (curLineLength - stop);\n          if (rBase < idx) {\n            // We didn't reach `stop` when stripping due to a bulge.\n            rBase = idx;\n          }\n        }\n      } else {\n        // Strip trailing whitespaces exceeding stop.\n        if (curLineLength > stop) {\n          bulge = bulge || stop;\n          rBase = str.length - (curLineLength - bulge);\n          lines[curLine] = str.substring(0, rBase);\n        }\n        bulge = 0;\n      }\n\n      // Bug: the current implementation of `wrapLineIndent` is buggy: we are not\n      // taking the extra space occupied by the additional indentation into account\n      // when wrapping the line. For example, in \"hard\" mode, we should hard-wrap\n      // long words at `wrapLen - wrapLinePrefix.length` instead of `wrapLen`;\n      // and remnants should also be wrapped at `wrapLen - wrapLinePrefix.length`.\n      if (preservedLine) {\n        // This is a preserved line, and the next output line isn't a\n        // preserved line.\n        preservedLine = false;\n        if (wrapLineIndentPat) {\n          idx = lines[curLine].substring(start).search(wrapLineIndentPat);\n          if (idx >= 0 && idx + wrapLineIndent > 0) {\n            wrapLinePrefix = new Array(idx + wrapLineIndent + 1).join(\" \");\n          } else {\n            wrapLinePrefix = \"\";\n          }\n        }\n      }\n\n      // Some remnants are left to the next line.\n      if (rBase) {\n        while (rBase + wrapLen < str.length) {\n          if (wsAll) {\n            ln = str.substring(rBase, rBase + wrapLen);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n          rBase += wrapLen;\n          curLine++;\n        }\n        if (beforeHardBreak) {\n          if (wsAll) {\n            ln = str.substring(rBase);\n            lines.push(prefix + wrapLinePrefix + ln);\n          } else {\n            lines.push(prefix + wrapLinePrefix);\n          }\n          curLine++;\n        } else {\n          ln = str.substring(rBase);\n          return wrapLinePrefix + ln;\n        }\n      }\n\n      return \"\";\n    }\n\n    for (i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n\n      if (chunk === \"\") {\n        continue;\n      }\n\n      if (typeof chunk !== \"string\") {\n        if (chunk.type === \"break\") {\n          // This is one or more line breaks.\n          // Each entry in `breaks` is just zero or more whitespaces.\n          if (respectLineBreaks !== \"none\") {\n            // Note that if `whitespace` is \"collapse\", we still need\n            // to collapse whitespaces in entries of `breaks`.\n            var breaks = chunk.breaks;\n            var num = breaks.length - 1;\n\n            if (respectLineBreaks === \"s\") {\n              // This is the most complex scenario. We have to check\n              // the line breaks one by one.\n              for (j = 0; j < num; j++) {\n                if (breaks[j + 1].length < respectNum) {\n                  // This line break should be stripped.\n                  if (wsCollapse) {\n                    breaks[j + 1] = \" \";\n                  } else {\n                    breaks[j + 1] = breaks[j] + breaks[j + 1];\n                  }\n                } else {\n                  // This line break should be preserved.\n                  // First finish off the current line.\n                  if (wsAll) {\n                    lines[curLine] += breaks[j];\n                    curLineLength += breaks[j].length;\n                  }\n                  finishOffCurLine(true);\n\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                  curLineLength = start + preservedLinePrefix.length;\n\n                  preservedLine = cleanLine = true;\n                }\n              }\n              // We are adding to either the existing line (if no line break\n              // is qualified for preservance) or a \"new\" line.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse || (!cleanLine && breaks[num] === \"\")) {\n                  breaks[num] = \" \";\n                }\n                lines[curLine] += breaks[num];\n                curLineLength += breaks[num].length;\n              }\n            } else if (respectLineBreaks === \"m\" && num < respectNum) {\n              // These line breaks should be stripped.\n              if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n                if (wsCollapse) {\n                  chunk = \" \";\n                } else {\n                  chunk = breaks.join(\"\");\n                  if (!cleanLine && chunk === \"\") {\n                    chunk = \" \";\n                  }\n                }\n                lines[curLine] += chunk;\n                curLineLength += chunk.length;\n              }\n            } else {\n              // 'all' || ('m' && num >= respectNum)\n              // These line breaks should be preserved.\n              if (wsStrip) {\n                // Finish off the current line.\n                finishOffCurLine(true);\n\n                for (j = 0; j < num; j++) {\n                  lines.push(prefix + preservedLinePrefix);\n                  curLine++;\n                }\n\n                curLineLength = start + preservedLinePrefix.length;\n                preservedLine = cleanLine = true;\n              } else {\n                if (wsAll || (preservedLine && cleanLine)) {\n                  lines[curLine] += breaks[0];\n                  curLineLength += breaks[0].length;\n                }\n\n                for (j = 0; j < num; j++) {\n                  // Finish off the current line.\n                  finishOffCurLine(true);\n\n                  lines.push(prefix + preservedLinePrefix + breaks[j + 1]);\n                  curLine++;\n                  curLineLength =\n                    start + preservedLinePrefix.length + breaks[j + 1].length;\n\n                  preservedLine = cleanLine = true;\n                }\n              }\n            }\n          } else {\n            // These line breaks should be stripped.\n            if (!cleanLine || wsAll || (wsLine && preservedLine)) {\n              chunk = chunk.remaining;\n\n              // Bug: If `wsAll` is true, `cleanLine` is false, and `chunk`\n              // is '', we insert a space to replace the line break. This\n              // space will be preserved even if we are at the end of an\n              // output line, which is wrong behavior. However, I'm not\n              // sure it's worth it to fix this edge case.\n              if (wsCollapse || (!cleanLine && chunk === \"\")) {\n                chunk = \" \";\n              }\n              lines[curLine] += chunk;\n              curLineLength += chunk.length;\n            }\n          }\n        } else if (chunk.type === \"skip\") {\n          // This is a skip string.\n          // Assumption: skip strings don't end with whitespaces.\n          if (curLineLength > stop) {\n            remnant = finishOffCurLine(false);\n\n            lines.push(prefix + wrapLinePrefix);\n            curLine++;\n            curLineLength = start + wrapLinePrefix.length;\n\n            if (remnant) {\n              lines[curLine] += remnant;\n              curLineLength += remnant.length;\n            }\n\n            cleanLine = true;\n          }\n          lines[curLine] += chunk.value;\n        }\n        continue;\n      }\n\n      var chunk2;\n      while (1) {\n        chunk2 = undefined;\n        if (\n          curLineLength + chunk.length > stop &&\n          curLineLength + (chunk2 = chunk.replace(tPat, \"\")).length > stop &&\n          chunk2 !== \"\" &&\n          curLineLength > start\n        ) {\n          // This line is full, add `chunk` to the next line\n          remnant = finishOffCurLine(false);\n\n          lines.push(prefix + wrapLinePrefix);\n          curLine++;\n          curLineLength = start + wrapLinePrefix.length;\n\n          if (remnant) {\n            lines[curLine] += remnant;\n            curLineLength += remnant.length;\n            cleanLine = true;\n            continue;\n          }\n\n          if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n            chunk = chunk.replace(pPat, \"\");\n          }\n          cleanLine = false;\n        } else {\n          // Add `chunk` to this line\n          if (cleanLine) {\n            if (wsStrip || (wsLine && !(preservedLine && cleanLine))) {\n              chunk = chunk.replace(pPat, \"\");\n              if (chunk !== \"\") {\n                cleanLine = false;\n              }\n            } else {\n              if (nonWsPat.test(chunk)) {\n                cleanLine = false;\n              }\n            }\n          }\n        }\n        break;\n      }\n      if (wsAll && chunk2 && curLineLength + chunk2.length > stop) {\n        bulge = curLineLength + chunk2.length;\n      }\n      lines[curLine] += chunk;\n      curLineLength += chunk.length;\n    }\n    // Finally, finish off the last line.\n    finishOffCurLine(true);\n    return lines.join(lineBreakStr);\n  };\n};\n\nlinewrap.soft = linewrap;\n\nlinewrap.hard = function (/*start, stop, params*/) {\n  var args = [].slice.call(arguments);\n  var last = args.length - 1;\n  if (typeof args[last] === \"object\") {\n    args[last].mode = \"hard\";\n  } else {\n    args.push({ mode: \"hard\" });\n  }\n  return linewrap.apply(null, args);\n};\n\nlinewrap.wrap = function (text /*, start, stop, params*/) {\n  var args = [].slice.call(arguments);\n  args.shift();\n  return linewrap.apply(null, args)(text);\n};\n\nexport default linewrap();\n","/**\n * Use the ImageData from a Canvas and turn the image in a 1-bit black and white image using dithering\n */\nclass CanvasDither {\n  /**\n   * Change the image to grayscale\n   *\n   * @param  {object}   image         The imageData of a Canvas 2d context\n   * @return {object}                 The resulting imageData\n   *\n   */\n  grayscale(image) {\n    for (let i = 0; i < image.data.length; i += 4) {\n      const luminance =\n        image.data[i] * 0.299 +\n        image.data[i + 1] * 0.587 +\n        image.data[i + 2] * 0.114;\n      image.data.fill(luminance, i, i + 3);\n    }\n\n    return image;\n  }\n\n  /**\n   * Change the image to blank and white using a simple threshold\n   *\n   * @param  {object}   image         The imageData of a Canvas 2d context\n   * @param  {number}   threshold     Threshold value (0-255)\n   * @return {object}                 The resulting imageData\n   *\n   */\n  threshold(image, threshold) {\n    for (let i = 0; i < image.data.length; i += 4) {\n      const luminance =\n        image.data[i] * 0.299 +\n        image.data[i + 1] * 0.587 +\n        image.data[i + 2] * 0.114;\n\n      const value = luminance < threshold ? 0 : 255;\n      image.data.fill(value, i, i + 3);\n    }\n\n    return image;\n  }\n\n  /**\n   * Change the image to blank and white using the Bayer algorithm\n   *\n   * @param  {object}   image         The imageData of a Canvas 2d context\n   * @param  {number}   threshold     Threshold value (0-255)\n   * @return {object}                 The resulting imageData\n   *\n   */\n  bayer(image, threshold) {\n    const thresholdMap = [\n      [15, 135, 45, 165],\n      [195, 75, 225, 105],\n      [60, 180, 30, 150],\n      [240, 120, 210, 90],\n    ];\n\n    for (let i = 0; i < image.data.length; i += 4) {\n      const luminance =\n        image.data[i] * 0.299 +\n        image.data[i + 1] * 0.587 +\n        image.data[i + 2] * 0.114;\n\n      const x = (i / 4) % image.width;\n      const y = Math.floor(i / 4 / image.width);\n      const map = Math.floor((luminance + thresholdMap[x % 4][y % 4]) / 2);\n      const value = map < threshold ? 0 : 255;\n      image.data.fill(value, i, i + 3);\n    }\n\n    return image;\n  }\n\n  /**\n   * Change the image to blank and white using the Floyd-Steinberg algorithm\n   *\n   * @param  {object}   image         The imageData of a Canvas 2d context\n   * @return {object}                 The resulting imageData\n   *\n   */\n  floydsteinberg(image) {\n    const width = image.width;\n    const luminance = new Uint8ClampedArray(image.width * image.height);\n\n    for (let l = 0, i = 0; i < image.data.length; l++, i += 4) {\n      luminance[l] =\n        image.data[i] * 0.299 +\n        image.data[i + 1] * 0.587 +\n        image.data[i + 2] * 0.114;\n    }\n\n    for (let l = 0, i = 0; i < image.data.length; l++, i += 4) {\n      const value = luminance[l] < 129 ? 0 : 255;\n      const error = Math.floor((luminance[l] - value) / 16);\n      image.data.fill(value, i, i + 3);\n\n      luminance[l + 1] += error * 7;\n      luminance[l + width - 1] += error * 3;\n      luminance[l + width] += error * 5;\n      luminance[l + width + 1] += error * 1;\n    }\n\n    return image;\n  }\n\n  /**\n   * Change the image to blank and white using the Atkinson algorithm\n   *\n   * @param  {object}   image         The imageData of a Canvas 2d context\n   * @return {object}                 The resulting imageData\n   *\n   */\n  atkinson(image) {\n    const width = image.width;\n    const luminance = new Uint8ClampedArray(image.width * image.height);\n\n    for (let l = 0, i = 0; i < image.data.length; l++, i += 4) {\n      luminance[l] =\n        image.data[i] * 0.299 +\n        image.data[i + 1] * 0.587 +\n        image.data[i + 2] * 0.114;\n    }\n\n    for (let l = 0, i = 0; i < image.data.length; l++, i += 4) {\n      const value = luminance[l] < 129 ? 0 : 255;\n      const error = Math.floor((luminance[l] - value) / 8);\n      image.data.fill(value, i, i + 3);\n\n      luminance[l + 1] += error;\n      luminance[l + 2] += error;\n      luminance[l + width - 1] += error;\n      luminance[l + width] += error;\n      luminance[l + width + 1] += error;\n      luminance[l + 2 * width] += error;\n    }\n\n    return image;\n  }\n}\n\nexport default new CanvasDither();\n","/**\n * Use the ImageData from a Canvas and flatten the image on a solid background\n */\nclass CanvasFlatten {\n  /**\n   * Change the image to grayscale\n   *\n   * @param  {object}   image         The imageData of a Canvas 2d context\n   * @param  {array}    background    Three values consisting of the r, g, b of the background\n   * @return {object}                 The resulting imageData\n   *\n   */\n  flatten(image, background) {\n    for (let i = 0; i < image.data.length; i += 4) {\n      const alpha = image.data[i + 3];\n      const invAlpha = 255 - alpha;\n\n      image.data[i] = (alpha * image.data[i] + invAlpha * background[0]) / 255;\n      image.data[i + 1] =\n        (alpha * image.data[i + 1] + invAlpha * background[1]) / 255;\n      image.data[i + 2] =\n        (alpha * image.data[i + 2] + invAlpha * background[2]) / 255;\n      image.data[i + 3] = 0xff;\n    }\n\n    return image;\n  }\n}\n\nexport default new CanvasFlatten();\n","const definitions = {\n  cp437: {\n    name: \"USA, Standard Europe\",\n    languages: [\"en\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp720: {\n    name: \"Arabic\",\n    languages: [\"ar\"],\n    offset: 128,\n    chars:\n      \"\\x80\\x81\\x84\\x86\\x8d\\x8e\\x8f\\x90\\u0651\\u0652\\u064b\\u064c\\u064d\\u064e\\u064f\\u0650\\u00a0\",\n  },\n  cp737: {\n    name: \"Greek\",\n    languages: [\"el\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp775: {\n    name: \"Baltic Rim\",\n    languages: [\"et\", \"lt\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp850: {\n    name: \"Multilingual\",\n    languages: [\"en\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp851: {\n    name: \"Greek\",\n    languages: [\"el\"],\n    offset: 128,\n    chars:\n      \"  \",\n  },\n  cp852: {\n    name: \"Latin 2\",\n    languages: [\"hu\", \"pl\", \"cz\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp853: {\n    name: \"Turkish\",\n    languages: [\"tr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp855: {\n    name: \"Cyrillic\",\n    languages: [\"bg\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp857: {\n    name: \"Turkish\",\n    languages: [\"tr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp858: {\n    name: \"Euro\",\n    languages: [\"en\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp860: {\n    name: \"Portuguese\",\n    languages: [\"pt\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp861: {\n    name: \"Icelandic\",\n    languages: [\"is\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp862: {\n    name: \"Hebrew\",\n    languages: [\"he\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp863: {\n    name: \"Canadian French\",\n    languages: [\"fr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp864: {\n    name: \"Arabic\",\n    languages: [\"ar\"],\n    offset: 0,\n    chars:\n      \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ \",\n  },\n  cp865: {\n    name: \"Nordic\",\n    languages: [\"sv\", \"dk\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp866: {\n    name: \"Cyrillic 2\",\n    languages: [\"ru\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp869: {\n    name: \"Greek\",\n    languages: [\"el\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp874: {\n    name: \"Thai\",\n    languages: [\"th\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp1098: {\n    name: \"Farsi\",\n    languages: [\"fa\"],\n    offset: 128,\n    chars:\n      \"\\u0020\\u0020\\u060c\\u061b\\u061f\\u064b\\u0622\\ufe82\\uf8fa\\u0627\\ufe8e\\uf8fb\\u0621\\u0623\\ufe84\\uf8f9\\u0624\\ufe8b\\u0628\\ufe91\\ufb56\\ufb58\\u062a\\ufe97\\u062b\\ufe9b\\u062c\\ufe9f\\ufb7a\\ufb7c\\u00d7\\u062d\\ufea3\\u062e\\ufea7\\u062f\\u0630\\u0631\\u0632\\ufb8a\\u0633\\ufeb3\\u0634\\ufeb7\\u0635\\ufebb\\u00ab\\u00bb\\u2591\\u2592\\u2593\\u2502\\u2524\\u0636\\ufebf\\ufec1\\ufec3\\u2563\\u2551\\u2557\\u255d\\u00a4\\ufec5\\u2510\\u2514\\u2534\\u252c\\u251c\\u2500\\u253c\\ufec7\\u0639\\u255a\\u2554\\u2569\\u2566\\u2560\\u2550\\u256c\\u0020\\ufeca\\ufecb\\ufecc\\u063a\\ufece\\ufecf\\ufed0\\u0641\\ufed3\\u2518\\u250c\\u2588\\u2584\\u0642\\ufed7\\u2580\\ufb8e\\ufedb\\ufb92\\ufb94\\u0644\\ufedf\\u0645\\ufee3\\u0646\\ufee7\\u0648\\u0647\\ufeeb\\ufeec\\ufba4\\ufbfc\\u00ad\\ufbfd\\ufbfe\\u0640\\u0660\\u0661\\u0662\\u0663\\u0664\\u0665\\u0666\\u0667\\u0668\\u0669\\u25a0\\u00a0\",\n  },\n  cp1118: {\n    name: \"Lithuanian\",\n    languages: [\"lt\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp1119: {\n    name: \"Lithuanian\",\n    languages: [\"lt\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp1125: {\n    name: \"Ukrainian\",\n    languages: [\"uk\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp1162: {\n    name: \"Thai\",\n    languages: [\"th\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp2001: {\n    name: \"Lithuanian KBL or 771\",\n    languages: [\"lt\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3001: {\n    name: \"Estonian 1 or 1116\",\n    languages: [\"et\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3002: {\n    name: \"Estonian 2\",\n    languages: [\"et\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3011: {\n    name: \"Latvian 1\",\n    languages: [\"lv\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3012: {\n    name: \"Latvian 2 (modified 866)\",\n    languages: [\"lv\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3021: {\n    name: \"Bulgarian (MIK)\",\n    languages: [\"bg\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3041: {\n    name: \"Maltese ISO 646\",\n    languages: [\"mt\"],\n    offset: 0,\n    chars:\n      \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ^_abcdefghijklmnopqrstuvwxyz\\u007F\",\n  },\n  cp3840: {\n    name: \"Russian (modified 866)\",\n    languages: [\"ru\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3841: {\n    name: \"Ghost\",\n    languages: [\"ru\"],\n    offset: 128,\n    chars:\n      \" !\\\"#$%&'()*+,-./0123456789:;<=>?\",\n  },\n  cp3843: {\n    name: \"Polish (Mazovia)\",\n    languages: [\"pl\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3844: {\n    name: \"Czech (Kamenick)\",\n    languages: [\"cz\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3845: {\n    name: \"Hungarian (CWI-2)\",\n    languages: [\"hu\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3846: {\n    name: \"Turkish\",\n    languages: [\"tr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  cp3847: {\n    name: \"Brazil ABNT\",\n    languages: [\"pt\"],\n    offset: 256,\n    chars: \"\",\n  },\n  cp3848: {\n    name: \"Brazil ABICOMP\",\n    languages: [\"pt\"],\n    offset: 160,\n    chars: \" \",\n  },\n  iso88591: {\n    name: \"Latin 1\",\n    languages: [\"en\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  iso88592: {\n    name: \"Latin 2\",\n    languages: [\"hu\", \"pl\", \"cz\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  iso88597: {\n    name: \"Greek\",\n    languages: [\"el\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  iso885915: {\n    name: \"Latin 9\",\n    languages: [\"fr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  rk1048: {\n    name: \"Kazakh\",\n    languages: [\"kk\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1250: {\n    name: \"Latin 2\",\n    languages: [\"hu\", \"pl\", \"cz\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1251: {\n    name: \"Cyrillic\",\n    languages: [\"ru\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1252: {\n    name: \"Latin\",\n    languages: [\"fr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1253: {\n    name: \"Greek\",\n    languages: [\"el\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1254: {\n    name: \"Turkish\",\n    languages: [\"tr\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1255: {\n    name: \"Hebrew\",\n    languages: [\"he\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1256: {\n    name: \"Arabic\",\n    languages: [\"ar\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1257: {\n    name: \"Baltic Rim\",\n    languages: [\"et\", \"lt\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n  windows1258: {\n    name: \"Vietnamese\",\n    languages: [\"vi\"],\n    offset: 128,\n    chars:\n      \" \",\n  },\n};\n\nconst strings = {\n  en: \"The quick brown fox jumps over the lazy dog.\",\n  jp: \"   \",\n  pt: \"O prximo vo  noite sobre o Atlntico, pe freqentemente o nico mdico.\",\n  fr: \"Les nafs githales htifs pondant  Nol o il gle sont srs d'tre dus en voyant leurs drles d'ufs abms.\",\n  sv: \"Flygande bckasiner ska strax hwila p mjuka tuvor.\",\n  dk: \"Quizdeltagerne spiste jordbr med flde\",\n  el: \"   \",\n  tr: \"Pijamal hasta, yaz ofre abucak gvendi.\",\n  ru: \"         \",\n  hu: \"rvztr tkrfrgp\",\n  pl: \"Pchn w t d jea lub om skrzy fig\",\n  cz: \"Mohu jst sklo, neubl mi.\",\n  ar: \"        .\",\n  et: \"Ma vin klaasi sa, see ei tee mulle midagi.\",\n  lt: \"A galiu valgyti stikl ir jis mans neeidia.\",\n  bg: \"   ,    .\",\n  is: \"g get eti gler n ess a meia mig.\",\n  he: \"       .\",\n  fa: \".       \",\n  uk: \"   ,     .\",\n  vi: \"Ti c th n thy tinh m khng hi g.\",\n  kk: \"\",\n  lv: \"Es varu st stiklu, tas man nekait.\",\n  mt: \"Nista' niekol il-ie u ma jagmilli xejn.\",\n  th: \" \",\n};\n\n/**\n * A library for converting Unicode to obscure single byte codepage for use with thermal printers\n */\nclass CodepageEncoder {\n  /**\n   * Get list of supported codepages\n   *\n   * @return {object}          Return the object, for easy chaining commands\n   *\n   */\n  static getEncodings() {\n    return Object.keys(definitions);\n  }\n\n  /**\n   * Get test strings for the specified codepage\n   *\n   * @param  {string}   codepage  The codepage\n   * @return {array}              Return an array with one or more objects\n   *                              containing a property for the language of\n   *                              the string and a property for the string itself\n   *\n   */\n  static getTestStrings(codepage) {\n    if (\n      typeof definitions[codepage] !== \"undefined\" &&\n      typeof definitions[codepage].languages !== \"undefined\"\n    ) {\n      return definitions[codepage].languages.map((i) => ({\n        language: i,\n        string: strings[i],\n      }));\n    }\n\n    return [];\n  }\n\n  /**\n   * Determine if the specified codepage is supported\n   *\n   * @param  {string}   codepage  The codepage\n   * @return {boolean}            Return a boolean, true if the encoding is supported,\n   *                              otherwise false\n   *\n   */\n  static supports(codepage) {\n    if (typeof definitions[codepage] === \"undefined\") {\n      return false;\n    }\n\n    if (typeof definitions[codepage].chars === \"undefined\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Encode a string in the specified codepage\n   *\n   * @param  {string}   input     Text that needs encoded to the specified codepage\n   * @param  {string}   codepage  The codepage\n   * @return {Uint8Array}         Return an array of bytes with the encoded string\n   *\n   */\n  static encode(input, codepage) {\n    const output = new Uint8Array(input.length);\n\n    let chars = \"\\u0000\".repeat(128);\n    let offset = 128;\n\n    if (\n      typeof definitions[codepage] !== \"undefined\" &&\n      typeof definitions[codepage].chars !== \"undefined\"\n    ) {\n      chars = definitions[codepage].chars;\n      offset = definitions[codepage].offset;\n    }\n\n    for (let c = 0; c < input.length; c++) {\n      const codepoint = input.codePointAt(c);\n\n      if (codepoint < 128) {\n        output[c] = codepoint;\n      } else {\n        const position = chars.indexOf(input[c]);\n\n        if (position !== -1) {\n          output[c] = offset + position;\n        } else if (\n          codepoint < 256 &&\n          (codepoint < offset || codepoint >= offset + chars.length)\n        ) {\n          output[c] = codepoint;\n        } else {\n          output[c] = 0x3f;\n        }\n      }\n    }\n\n    return output;\n  }\n\n  /**\n   * Encode a string in the most optimal set of codepages.\n   *\n   * @param  {string}   input         Text that needs encoded\n   * @param  {array}    candidates    An array of candidate codepages that are allowed to be used, ranked by importance\n   * @return {Uint8Array}             Return an array of bytes with the encoded string\n   *\n   */\n  static autoEncode(input, candidates) {\n    const fragments = [];\n    let fragment = -1;\n    let current;\n\n    for (let c = 0; c < input.length; c++) {\n      const codepoint = input.codePointAt(c);\n\n      let available;\n      let char = 0;\n\n      if (codepoint < 128) {\n        available = current || candidates[0];\n        char = codepoint;\n      }\n\n      if (!available && current) {\n        const position = definitions[current].chars.indexOf(input[c]);\n\n        if (position !== -1) {\n          available = current;\n          char = definitions[current].offset + position;\n        }\n      }\n\n      if (!available) {\n        for (let i = 0; i < candidates.length; i++) {\n          const position = definitions[candidates[i]].chars.indexOf(input[c]);\n\n          if (position !== -1) {\n            available = candidates[i];\n            char = definitions[candidates[i]].offset + position;\n            break;\n          }\n        }\n      }\n\n      if (!available) {\n        available = current || candidates[0];\n        char = 0x3f;\n      }\n\n      if (current != available) {\n        if (current) {\n          fragments[fragment].bytes = new Uint8Array(fragments[fragment].bytes);\n        }\n\n        fragment++;\n        fragments[fragment] = {\n          codepage: available,\n          bytes: [],\n        };\n\n        current = available;\n      }\n\n      fragments[fragment].bytes.push(char);\n    }\n\n    if (current) {\n      fragments[fragment].bytes = new Uint8Array(fragments[fragment].bytes);\n    }\n\n    return fragments;\n  }\n}\n\nexport default CodepageEncoder;\n","export const createCanvas = function (width, height) {\n    return Object.assign(document.createElement(\"canvas\"), {\n        width: width,\n        height: height,\n    });\n};","import linewrap from \"./linewrap.js\";\nimport Dither from \"./canvas-dither.js\";\nimport Flatten from \"./canvas-flatten.js\";\nimport CodepageEncoder from \"./codepage-encoder.js\";\nimport { createCanvas } from \"./canvas.js\";\n\nconst codepageMappings = {\n  epson: {\n    cp437: 0x00,\n    shiftjis: 0x01,\n    cp850: 0x02,\n    cp860: 0x03,\n    cp863: 0x04,\n    cp865: 0x05,\n    cp851: 0x0b,\n    cp853: 0x0c,\n    cp857: 0x0d,\n    cp737: 0x0e,\n    iso88597: 0x0f,\n    windows1252: 0x10,\n    cp866: 0x11,\n    cp852: 0x12,\n    cp858: 0x13,\n    cp720: 0x20,\n    cp775: 0x21,\n    cp855: 0x22,\n    cp861: 0x23,\n    cp862: 0x24,\n    cp864: 0x25,\n    cp869: 0x26,\n    iso88592: 0x27,\n    iso885915: 0x28,\n    cp1098: 0x29,\n    cp1118: 0x2a,\n    cp1119: 0x2b,\n    cp1125: 0x2c,\n    windows1250: 0x2d,\n    windows1251: 0x2e,\n    windows1253: 0x2f,\n    windows1254: 0x30,\n    windows1255: 0x31,\n    windows1256: 0x32,\n    windows1257: 0x33,\n    windows1258: 0x34,\n    rk1048: 0x35,\n  },\n\n  zjiang: {\n    cp437: 0x00,\n    shiftjis: 0x01,\n    cp850: 0x02,\n    cp860: 0x03,\n    cp863: 0x04,\n    cp865: 0x05,\n    windows1252: 0x10,\n    cp866: 0x11,\n    cp852: 0x12,\n    cp858: 0x13,\n    windows1255: 0x20,\n    cp861: 0x38,\n    cp855: 0x3c,\n    cp857: 0x3d,\n    cp862: 0x3e,\n    cp864: 0x3f,\n    cp737: 0x40,\n    cp851: 0x41,\n    cp869: 0x42,\n    cp1119: 0x44,\n    cp1118: 0x45,\n    windows1250: 0x48,\n    windows1251: 0x49,\n    cp3840: 0x4a,\n    cp3843: 0x4c,\n    cp3844: 0x4d,\n    cp3845: 0x4e,\n    cp3846: 0x4f,\n    cp3847: 0x50,\n    cp3848: 0x51,\n    cp2001: 0x53,\n    cp3001: 0x54,\n    cp3002: 0x55,\n    cp3011: 0x56,\n    cp3012: 0x57,\n    cp3021: 0x58,\n    cp3041: 0x59,\n    windows1253: 0x5a,\n    windows1254: 0x5b,\n    windows1256: 0x5c,\n    cp720: 0x5d,\n    windows1258: 0x5e,\n    cp775: 0x5f,\n  },\n\n  bixolon: {\n    cp437: 0x00,\n    shiftjis: 0x01,\n    cp850: 0x02,\n    cp860: 0x03,\n    cp863: 0x04,\n    cp865: 0x05,\n    cp851: 0x0b,\n    cp858: 0x13,\n  },\n\n  star: {\n    cp437: 0x00,\n    shiftjis: 0x01,\n    cp850: 0x02,\n    cp860: 0x03,\n    cp863: 0x04,\n    cp865: 0x05,\n    windows1252: 0x10,\n    cp866: 0x11,\n    cp852: 0x12,\n    cp858: 0x13,\n  },\n\n  legacy: {\n    cp437: 0x00,\n    cp737: 0x40,\n    cp850: 0x02,\n    cp775: 0x5f,\n    cp852: 0x12,\n    cp855: 0x3c,\n    cp857: 0x3d,\n    cp858: 0x13,\n    cp860: 0x03,\n    cp861: 0x38,\n    cp862: 0x3e,\n    cp863: 0x04,\n    cp864: 0x1c,\n    cp865: 0x05,\n    cp866: 0x11,\n    cp869: 0x42,\n    cp936: 0xff,\n    cp949: 0xfd,\n    cp950: 0xfe,\n    cp1252: 0x10,\n    iso88596: 0x16,\n    shiftjis: 0xfc,\n    windows874: 0x1e,\n    windows1250: 0x48,\n    windows1251: 0x49,\n    windows1252: 0x47,\n    windows1253: 0x5a,\n    windows1254: 0x5b,\n    windows1255: 0x20,\n    windows1256: 0x5c,\n    windows1257: 0x19,\n    windows1258: 0x5e,\n  },\n};\n\n/**\n * Create a byte stream based on commands for ESC/POS printers\n */\nclass EscPosEncoder {\n  /**\n   * Create a new object\n   *\n   * @param  {object}   options   Object containing configuration options\n   */\n  constructor(options) {\n    this._reset(options);\n  }\n\n  /**\n   * Reset the state of the object\n   *\n   * @param  {object}   options   Object containing configuration options\n   */\n  _reset(options) {\n    this._options = Object.assign(\n      {\n        width: null,\n        embedded: false,\n        wordWrap: true,\n        imageMode: \"column\",\n        codepageMapping: \"epson\",\n        codepageCandidates: [\n          \"cp437\",\n          \"cp858\",\n          \"cp860\",\n          \"cp861\",\n          \"cp863\",\n          \"cp865\",\n          \"cp852\",\n          \"cp857\",\n          \"cp855\",\n          \"cp866\",\n          \"cp869\",\n        ],\n      },\n      options\n    );\n\n    this._embedded = this._options.width && this._options.embedded;\n\n    this._buffer = [];\n    this._queued = [];\n    this._cursor = 0;\n    this._codepage = \"ascii\";\n\n    this._state = {\n      codepage: 0,\n      align: \"left\",\n      bold: false,\n      italic: false,\n      underline: false,\n      invert: false,\n      width: 1,\n      height: 1,\n    };\n  }\n\n  /**\n   * Encode a string with the current code page\n   *\n   * @param  {string}   value  String to encode\n   * @return {object}          Encoded string as a ArrayBuffer\n   *\n   */\n  _encode(value) {\n    if (this._codepage != \"auto\") {\n      return CodepageEncoder.encode(value, this._codepage);\n    }\n\n    let codepages;\n\n    if (typeof this._options.codepageMapping == \"string\") {\n      codepages = codepageMappings[this._options.codepageMapping];\n    } else {\n      codepages = this._options.codepageMapping;\n    }\n\n    const fragments = CodepageEncoder.autoEncode(\n      value,\n      this._options.codepageCandidates\n    );\n\n    let length = 0;\n    for (let f = 0; f < fragments.length; f++) {\n      length += 3 + fragments[f].bytes.byteLength;\n    }\n\n    const buffer = new Uint8Array(length);\n    let i = 0;\n\n    for (let f = 0; f < fragments.length; f++) {\n      buffer.set([0x1b, 0x74, codepages[fragments[f].codepage]], i);\n      buffer.set(fragments[f].bytes, i + 3);\n      i += 3 + fragments[f].bytes.byteLength;\n\n      this._state.codepage = codepages[fragments[f].codepage];\n    }\n\n    return buffer;\n  }\n\n  /**\n   * Add commands to the queue\n   *\n   * @param  {array}   value  Add array of numbers, arrays, buffers or Uint8Arrays to add to the buffer\n   *\n   */\n  _queue(value) {\n    value.forEach((item) => this._queued.push(item));\n  }\n\n  /**\n   * Flush current queue to the buffer\n   *\n   */\n  _flush() {\n    if (this._embedded) {\n      let indent = this._options.width - this._cursor;\n\n      if (this._state.align == \"left\") {\n        this._queued.push(new Array(indent).fill(0x20));\n      }\n\n      if (this._state.align == \"center\") {\n        const remainder = indent % 2;\n        indent = indent >> 1;\n\n        if (indent > 0) {\n          this._queued.push(new Array(indent).fill(0x20));\n        }\n\n        if (indent + remainder > 0) {\n          this._queued.unshift(new Array(indent + remainder).fill(0x20));\n        }\n      }\n\n      if (this._state.align == \"right\") {\n        this._queued.unshift(new Array(indent).fill(0x20));\n      }\n    }\n\n    this._buffer = this._buffer.concat(this._queued);\n\n    this._queued = [];\n    this._cursor = 0;\n  }\n\n  /**\n   * Wrap the text while respecting the position of the cursor\n   *\n   * @param  {string}   value     String to wrap after the width of the paper has been reached\n   * @param  {number}   position  Position on which to force a wrap\n   * @return {array}              Array with each line\n   */\n  _wrap(value, position) {\n    if (position || (this._options.wordWrap && this._options.width)) {\n      const indent = \"-\".repeat(this._cursor);\n      const w = linewrap(position || this._options.width, {\n        lineBreak: \"\\n\",\n        whitespace: \"all\",\n      });\n      const result = w(indent + value)\n        .substring(this._cursor)\n        .split(\"\\n\");\n\n      return result;\n    }\n\n    return [value];\n  }\n\n  /**\n   * Restore styles and codepages after drawing boxes or lines\n   */\n  _restoreState() {\n    this.bold(this._state.bold);\n    this.italic(this._state.italic);\n    this.underline(this._state.underline);\n    this.invert(this._state.invert);\n\n    this._queue([0x1b, 0x74, this._state.codepage]);\n  }\n\n  /**\n   * Get code page identifier for the specified code page and mapping\n   *\n   * @param  {string}   codepage  Required code page\n   * @return {number}             Identifier for the current printer according to the specified mapping\n   */\n  _getCodepageIdentifier(codepage) {\n    let codepages;\n\n    if (typeof this._options.codepageMapping == \"string\") {\n      codepages = codepageMappings[this._options.codepageMapping];\n    } else {\n      codepages = this._options.codepageMapping;\n    }\n\n    return codepages[codepage];\n  }\n\n  /**\n   * Initialize the printer\n   *\n   * @return {object}          Return the object, for easy chaining commands\n   *\n   */\n  initialize() {\n    this._queue([0x1b, 0x40]);\n\n    this._flush();\n\n    return this;\n  }\n\n  /**\n   * Change the code page\n   *\n   * @param  {string}   codepage  The codepage that we set the printer to\n   * @return {object}             Return the object, for easy chaining commands\n   *\n   */\n  codepage(codepage) {\n    if (codepage === \"auto\") {\n      this._codepage = codepage;\n      return this;\n    }\n\n    if (!CodepageEncoder.supports(codepage)) {\n      throw new Error(\"Unknown codepage\");\n    }\n\n    let codepages;\n\n    if (typeof this._options.codepageMapping == \"string\") {\n      codepages = codepageMappings[this._options.codepageMapping];\n    } else {\n      codepages = this._options.codepageMapping;\n    }\n\n    if (typeof codepages[codepage] !== \"undefined\") {\n      this._codepage = codepage;\n      this._state.codepage = codepages[codepage];\n\n      this._queue([0x1b, 0x74, codepages[codepage]]);\n    } else {\n      throw new Error(\"Codepage not supported by printer\");\n    }\n\n    return this;\n  }\n\n  /**\n   * Print text\n   *\n   * @param  {string}   value  Text that needs to be printed\n   * @param  {number}   wrap   Wrap text after this many positions\n   * @return {object}          Return the object, for easy chaining commands\n   *\n   */\n  text(value, wrap) {\n    const lines = this._wrap(value, wrap);\n\n    for (let l = 0; l < lines.length; l++) {\n      const bytes = this._encode(lines[l]);\n\n      this._queue([bytes]);\n\n      this._cursor += lines[l].length * this._state.width;\n\n      if (this._options.width && !this._embedded) {\n        this._cursor = this._cursor % this._options.width;\n      }\n\n      if (l < lines.length - 1) {\n        this.newline();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Print a newline\n   *\n   * @return {object}          Return the object, for easy chaining commands\n   *\n   */\n  newline() {\n    this._flush();\n\n    this._queue([0x0a, 0x0d]);\n\n    if (this._embedded) {\n      this._restoreState();\n    }\n\n    return this;\n  }\n\n  /**\n   * Print text, followed by a newline\n   *\n   * @param  {string}   value  Text that needs to be printed\n   * @param  {number}   wrap   Wrap text after this many positions\n   * @return {object}          Return the object, for easy chaining commands\n   *\n   */\n  line(value, wrap) {\n    this.text(value, wrap);\n    this.newline();\n\n    return this;\n  }\n\n  /**\n   * Underline text\n   *\n   * @param  {boolean|number}   value  true to turn on underline, false to turn off, or 2 for double underline\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  underline(value) {\n    if (typeof value === \"undefined\") {\n      value = !this._state.underline;\n    }\n\n    this._state.underline = value;\n\n    this._queue([0x1b, 0x2d, Number(value)]);\n\n    return this;\n  }\n\n  /**\n   * Italic text\n   *\n   * @param  {boolean}          value  true to turn on italic, false to turn off\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  italic(value) {\n    if (typeof value === \"undefined\") {\n      value = !this._state.italic;\n    }\n\n    this._state.italic = value;\n\n    this._queue([0x1b, 0x34, Number(value)]);\n\n    return this;\n  }\n\n  /**\n   * Bold text\n   *\n   * @param  {boolean}          value  true to turn on bold, false to turn off\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  bold(value) {\n    if (typeof value === \"undefined\") {\n      value = !this._state.bold;\n    }\n\n    this._state.bold = value;\n\n    this._queue([0x1b, 0x45, Number(value)]);\n\n    return this;\n  }\n\n  /**\n   * Change width of text\n   *\n   * @param  {number}          width    The width of the text, 1 - 8\n   * @return {object}                   Return the object, for easy chaining commands\n   *\n   */\n  width(width) {\n    if (typeof width === \"undefined\") {\n      width = 1;\n    }\n\n    if (typeof width !== \"number\") {\n      throw new Error(\"Width must be a number\");\n    }\n\n    if (width < 1 || width > 8) {\n      throw new Error(\"Width must be between 1 and 8\");\n    }\n\n    this._state.width = width;\n\n    this._queue([\n      0x1d,\n      0x21,\n      (this._state.height - 1) | ((this._state.width - 1) << 4),\n    ]);\n\n    return this;\n  }\n\n  /**\n   * Change height of text\n   *\n   * @param  {number}          height  The height of the text, 1 - 8\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  height(height) {\n    if (typeof height === \"undefined\") {\n      height = 1;\n    }\n\n    if (typeof height !== \"number\") {\n      throw new Error(\"Height must be a number\");\n    }\n\n    if (height < 1 || height > 8) {\n      throw new Error(\"Height must be between 1 and 8\");\n    }\n\n    this._state.height = height;\n\n    this._queue([\n      0x1d,\n      0x21,\n      (this._state.height - 1) | ((this._state.width - 1) << 4),\n    ]);\n\n    return this;\n  }\n\n  /**\n   * Invert text\n   *\n   * @param  {boolean}          value  true to turn on white text on black, false to turn off\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  invert(value) {\n    if (typeof value === \"undefined\") {\n      value = !this._state.invert;\n    }\n\n    this._state.invert = value;\n\n    this._queue([0x1d, 0x42, Number(value)]);\n\n    return this;\n  }\n\n  /**\n   * Change text size\n   *\n   * @param  {string}          value   small or normal\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  size(value) {\n    if (value === \"small\") {\n      value = 0x01;\n    } else {\n      value = 0x00;\n    }\n\n    this._queue([0x1b, 0x4d, value]);\n\n    return this;\n  }\n\n  /**\n   * Change text alignment\n   *\n   * @param  {string}          value   left, center or right\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  align(value) {\n    const alignments = {\n      left: 0x00,\n      center: 0x01,\n      right: 0x02,\n    };\n\n    if (value in alignments) {\n      this._state.align = value;\n\n      if (!this._embedded) {\n        this._queue([0x1b, 0x61, alignments[value]]);\n      }\n    } else {\n      throw new Error(\"Unknown alignment\");\n    }\n\n    return this;\n  }\n\n  /**\n   * Insert a table\n   *\n   * @param  {array}           columns  The column definitions\n   * @param  {array}           data     Array containing rows. Each row is an array containing cells.\n   *                                    Each cell can be a string value, or a callback function.\n   *                                    The first parameter of the callback is the encoder object on\n   *                                    which the function can call its methods.\n   * @return {object}                   Return the object, for easy chaining commands\n   *\n   */\n  table(columns, data) {\n    if (this._cursor != 0) {\n      this.newline();\n    }\n\n    for (let r = 0; r < data.length; r++) {\n      const lines = [];\n      let maxLines = 0;\n\n      for (let c = 0; c < columns.length; c++) {\n        const cell = [];\n\n        if (typeof data[r][c] === \"string\") {\n          const w = linewrap(columns[c].width, { lineBreak: \"\\n\" });\n          const fragments = w(data[r][c]).split(\"\\n\");\n\n          for (let f = 0; f < fragments.length; f++) {\n            if (columns[c].align == \"right\") {\n              cell[f] = this._encode(fragments[f].padStart(columns[c].width));\n            } else {\n              cell[f] = this._encode(fragments[f].padEnd(columns[c].width));\n            }\n          }\n        }\n\n        if (typeof data[r][c] === \"function\") {\n          const columnEncoder = new EscPosEncoder(\n            Object.assign({}, this._options, {\n              width: columns[c].width,\n              embedded: true,\n            })\n          );\n\n          columnEncoder._codepage = this._codepage;\n          columnEncoder.align(columns[c].align);\n          data[r][c](columnEncoder);\n          const encoded = columnEncoder.encode();\n\n          let fragment = [];\n\n          for (let e = 0; e < encoded.byteLength; e++) {\n            if (e < encoded.byteLength - 1) {\n              if (encoded[e] === 0x0a && encoded[e + 1] === 0x0d) {\n                cell.push(fragment);\n                fragment = [];\n\n                e++;\n                continue;\n              }\n            }\n\n            fragment.push(encoded[e]);\n          }\n\n          if (fragment.length) {\n            cell.push(fragment);\n          }\n        }\n\n        maxLines = Math.max(maxLines, cell.length);\n        lines[c] = cell;\n      }\n\n      for (let c = 0; c < columns.length; c++) {\n        if (lines[c].length < maxLines) {\n          for (let p = lines[c].length; p < maxLines; p++) {\n            let verticalAlign = \"top\";\n            if (typeof columns[c].verticalAlign !== \"undefined\") {\n              verticalAlign = columns[c].verticalAlign;\n            }\n\n            if (verticalAlign == \"bottom\") {\n              lines[c].unshift(new Array(columns[c].width).fill(0x20));\n            } else {\n              lines[c].push(new Array(columns[c].width).fill(0x20));\n            }\n          }\n        }\n      }\n\n      for (let l = 0; l < maxLines; l++) {\n        for (let c = 0; c < columns.length; c++) {\n          if (typeof columns[c].marginLeft !== \"undefined\") {\n            this.raw(new Array(columns[c].marginLeft).fill(0x20));\n          }\n\n          this.raw(lines[c][l]);\n\n          if (typeof columns[c].marginRight !== \"undefined\") {\n            this.raw(new Array(columns[c].marginRight).fill(0x20));\n          }\n        }\n\n        this.newline();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Insert a horizontal rule\n   *\n   * @param  {object}          options  And object with the following properties:\n   *                                    - style: The style of the line, either single or double\n   *                                    - width: The width of the line, by default the width of the paper\n   * @return {object}                   Return the object, for easy chaining commands\n   *\n   */\n  rule(options) {\n    options = Object.assign(\n      {\n        style: \"single\",\n        width: this._options.width || 10,\n      },\n      options || {}\n    );\n\n    this._queue([\n      0x1b,\n      0x74,\n      this._getCodepageIdentifier(\"cp437\"),\n      new Array(options.width).fill(options.style === \"double\" ? 0xcd : 0xc4),\n    ]);\n\n    this._queue([0x1b, 0x74, this._state.codepage]);\n\n    this.newline();\n\n    return this;\n  }\n\n  /**\n   * Insert a horizontal rule\n   *\n   * @param  {object}           options   And object with the following properties:\n   *                                      - style: The style of the border, either single or double\n   *                                      - width: The width of the box, by default the width of the paper, if specified\n   *                                      - marginLeft: Space between the left border and the left side of the paper\n   *                                      - marginRight: Space between the right border and the right side of the paper\n   *                                      - paddingLeft: Space between the contents and the left border of the box\n   *                                      - paddingRight: Space between the contents and the right border of the box\n   * @param  {string|function}  contents  A string value, or a callback function.\n   *                                      The first parameter of the callback is the encoder object on\n   *                                      which the function can call its methods.\n   * @return {object}                     Return the object, for easy chaining commands\n   *\n   */\n  box(options, contents) {\n    options = Object.assign(\n      {\n        style: \"single\",\n        width: this._options.width || 30,\n        marginLeft: 0,\n        marginRight: 0,\n        paddingLeft: 0,\n        paddingRight: 0,\n      },\n      options || {}\n    );\n\n    let elements;\n\n    if (options.style == \"double\") {\n      elements = [0xc9, 0xbb, 0xc8, 0xbc, 0xcd, 0xba]; // \n    } else {\n      elements = [0xda, 0xbf, 0xc0, 0xd9, 0xc4, 0xb3]; // \n    }\n\n    if (this._cursor != 0) {\n      this.newline();\n    }\n\n    this._restoreState();\n\n    this._queue([0x1b, 0x74, this._getCodepageIdentifier(\"cp437\")]);\n\n    this._queue([\n      new Array(options.marginLeft).fill(0x20),\n      elements[0],\n      new Array(options.width - 2).fill(elements[4]),\n      elements[1],\n      new Array(options.marginRight).fill(0x20),\n    ]);\n\n    this.newline();\n\n    const cell = [];\n\n    if (typeof contents === \"string\") {\n      const w = linewrap(\n        options.width - 2 - options.paddingLeft - options.paddingRight,\n        { lineBreak: \"\\n\" }\n      );\n      const fragments = w(contents).split(\"\\n\");\n\n      for (let f = 0; f < fragments.length; f++) {\n        if (options.align == \"right\") {\n          cell[f] = this._encode(\n            fragments[f].padStart(\n              options.width - 2 - options.paddingLeft - options.paddingRight\n            )\n          );\n        } else {\n          cell[f] = this._encode(\n            fragments[f].padEnd(\n              options.width - 2 - options.paddingLeft - options.paddingRight\n            )\n          );\n        }\n      }\n    }\n\n    if (typeof contents === \"function\") {\n      const columnEncoder = new EscPosEncoder(\n        Object.assign({}, this._options, {\n          width: options.width - 2 - options.paddingLeft - options.paddingRight,\n          embedded: true,\n        })\n      );\n\n      columnEncoder._codepage = this._codepage;\n      columnEncoder.align(options.align);\n      contents(columnEncoder);\n      const encoded = columnEncoder.encode();\n\n      let fragment = [];\n\n      for (let e = 0; e < encoded.byteLength; e++) {\n        if (e < encoded.byteLength - 1) {\n          if (encoded[e] === 0x0a && encoded[e + 1] === 0x0d) {\n            cell.push(fragment);\n            fragment = [];\n\n            e++;\n            continue;\n          }\n        }\n\n        fragment.push(encoded[e]);\n      }\n\n      if (fragment.length) {\n        cell.push(fragment);\n      }\n    }\n\n    for (let c = 0; c < cell.length; c++) {\n      this._queue([\n        new Array(options.marginLeft).fill(0x20),\n        elements[5],\n        new Array(options.paddingLeft).fill(0x20),\n      ]);\n\n      this._queue([cell[c]]);\n\n      this._restoreState();\n\n      this._queue([0x1b, 0x74, this._getCodepageIdentifier(\"cp437\")]);\n\n      this._queue([\n        new Array(options.paddingRight).fill(0x20),\n        elements[5],\n        new Array(options.marginRight).fill(0x20),\n      ]);\n\n      this.newline();\n    }\n\n    this._queue([\n      new Array(options.marginLeft).fill(0x20),\n      elements[2],\n      new Array(options.width - 2).fill(elements[4]),\n      elements[3],\n      new Array(options.marginRight).fill(0x20),\n    ]);\n\n    this._restoreState();\n\n    this.newline();\n\n    return this;\n  }\n\n  /**\n   * Barcode\n   *\n   * @param  {string}           value  the value of the barcode\n   * @param  {string}           symbology  the type of the barcode\n   * @param  {number}           height  height of the barcode\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  barcode(value, symbology, height) {\n    if (this._embedded) {\n      throw new Error(\"Barcodes are not supported in table cells or boxes\");\n    }\n\n    const symbologies = {\n      upca: 0x00,\n      upce: 0x01,\n      ean13: 0x02,\n      ean8: 0x03,\n      code39: 0x04,\n      coda39: 0x04 /* typo, leave here for backwards compatibility */,\n      itf: 0x05,\n      codabar: 0x06,\n      code93: 0x48,\n      code128: 0x49,\n      \"gs1-128\": 0x50,\n      \"gs1-databar-omni\": 0x51,\n      \"gs1-databar-truncated\": 0x52,\n      \"gs1-databar-limited\": 0x53,\n      \"gs1-databar-expanded\": 0x54,\n      \"code128-auto\": 0x55,\n    };\n\n    if (symbology in symbologies) {\n      const bytes = CodepageEncoder.encode(value, \"ascii\");\n\n      if (this._cursor != 0) {\n        this.newline();\n      }\n\n      this._queue([\n        0x1d,\n        0x68,\n        height,\n        0x1d,\n        0x77,\n        symbology === \"code39\" ? 0x02 : 0x03,\n      ]);\n\n      if (symbology == \"code128\" && bytes[0] !== 0x7b) {\n        /* Not yet encodeded Code 128, assume data is Code B, which is similar to ASCII without control chars */\n\n        this._queue([\n          0x1d,\n          0x6b,\n          symbologies[symbology],\n          bytes.length + 2,\n          0x7b,\n          0x42,\n          bytes,\n        ]);\n      } else if (symbologies[symbology] > 0x40) {\n        /* Function B symbologies */\n\n        this._queue([0x1d, 0x6b, symbologies[symbology], bytes.length, bytes]);\n      } else {\n        /* Function A symbologies */\n\n        this._queue([0x1d, 0x6b, symbologies[symbology], bytes, 0x00]);\n      }\n    } else {\n      throw new Error(\"Symbology not supported by printer\");\n    }\n\n    this._flush();\n\n    return this;\n  }\n\n  /**\n   * QR code\n   *\n   * @param  {string}           value  the value of the qr code\n   * @param  {number}           model  model of the qrcode, either 1 or 2\n   * @param  {number}           size   size of the qrcode, a value between 1 and 8\n   * @param  {string}           errorlevel  the amount of error correction used, either 'l', 'm', 'q', 'h'\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  qrcode(value, model, size, errorlevel) {\n    if (this._embedded) {\n      throw new Error(\"QR codes are not supported in table cells or boxes\");\n    }\n\n    /* Force printing the print buffer and moving to a new line */\n\n    this._queue([0x0a]);\n\n    /* Model */\n\n    const models = {\n      1: 0x31,\n      2: 0x32,\n    };\n\n    if (typeof model === \"undefined\") {\n      model = 2;\n    }\n\n    if (model in models) {\n      this._queue([\n        0x1d,\n        0x28,\n        0x6b,\n        0x04,\n        0x00,\n        0x31,\n        0x41,\n        models[model],\n        0x00,\n      ]);\n    } else {\n      throw new Error(\"Model must be 1 or 2\");\n    }\n\n    /* Size */\n\n    if (typeof size === \"undefined\") {\n      size = 6;\n    }\n\n    if (typeof size !== \"number\") {\n      throw new Error(\"Size must be a number\");\n    }\n\n    if (size < 1 || size > 8) {\n      throw new Error(\"Size must be between 1 and 8\");\n    }\n\n    this._queue([0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x43, size]);\n\n    /* Error level */\n\n    const errorlevels = {\n      l: 0x30,\n      m: 0x31,\n      q: 0x32,\n      h: 0x33,\n    };\n\n    if (typeof errorlevel === \"undefined\") {\n      errorlevel = \"m\";\n    }\n\n    if (errorlevel in errorlevels) {\n      this._queue([\n        0x1d,\n        0x28,\n        0x6b,\n        0x03,\n        0x00,\n        0x31,\n        0x45,\n        errorlevels[errorlevel],\n      ]);\n    } else {\n      throw new Error(\"Error level must be l, m, q or h\");\n    }\n\n    /* Data */\n\n    const bytes = CodepageEncoder.encode(value, \"iso88591\");\n    const length = bytes.length + 3;\n\n    this._queue([\n      0x1d,\n      0x28,\n      0x6b,\n      length % 0xff,\n      length / 0xff,\n      0x31,\n      0x50,\n      0x30,\n      bytes,\n    ]);\n\n    /* Print QR code */\n\n    this._queue([0x1d, 0x28, 0x6b, 0x03, 0x00, 0x31, 0x51, 0x30]);\n\n    this._flush();\n\n    return this;\n  }\n\n  /**\n   * Image\n   *\n   * @param  {object}         element  an element, like a canvas or image that needs to be printed\n   * @param  {number}         width  width of the image on the printer\n   * @param  {number}         height  height of the image on the printer\n   * @param  {string}         algorithm  the dithering algorithm for making the image black and white\n   * @param  {number}         threshold  threshold for the dithering algorithm\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  image(element, width, height, algorithm, threshold) {\n    if (this._embedded) {\n      throw new Error(\"Images are not supported in table cells or boxes\");\n    }\n\n    if (width % 8 !== 0) {\n      throw new Error(\"Width must be a multiple of 8\");\n    }\n\n    if (height % 8 !== 0) {\n      throw new Error(\"Height must be a multiple of 8\");\n    }\n\n    if (typeof algorithm === \"undefined\") {\n      algorithm = \"threshold\";\n    }\n\n    if (typeof threshold === \"undefined\") {\n      threshold = 128;\n    }\n\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext(\"2d\");\n    context.drawImage(element, 0, 0, width, height);\n    let image = context.getImageData(0, 0, width, height);\n\n    image = Flatten.flatten(image, [0xff, 0xff, 0xff]);\n\n    switch (algorithm) {\n      case \"threshold\":\n        image = Dither.threshold(image, threshold);\n        break;\n      case \"bayer\":\n        image = Dither.bayer(image, threshold);\n        break;\n      case \"floydsteinberg\":\n        image = Dither.floydsteinberg(image);\n        break;\n      case \"atkinson\":\n        image = Dither.atkinson(image);\n        break;\n    }\n\n    const getPixel = (x, y) =>\n      x < width && y < height\n        ? image.data[(width * y + x) * 4] > 0\n          ? 0\n          : 1\n        : 0;\n\n    const getColumnData = (width, height) => {\n      const data = [];\n\n      for (let s = 0; s < Math.ceil(height / 24); s++) {\n        const bytes = new Uint8Array(width * 3);\n\n        for (let x = 0; x < width; x++) {\n          for (let c = 0; c < 3; c++) {\n            for (let b = 0; b < 8; b++) {\n              bytes[x * 3 + c] |= getPixel(x, s * 24 + b + 8 * c) << (7 - b);\n            }\n          }\n        }\n\n        data.push(bytes);\n      }\n\n      return data;\n    };\n\n    const getRowData = (width, height) => {\n      const bytes = new Uint8Array((width * height) >> 3);\n\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x = x + 8) {\n          for (let b = 0; b < 8; b++) {\n            bytes[y * (width >> 3) + (x >> 3)] |= getPixel(x + b, y) << (7 - b);\n          }\n        }\n      }\n\n      return bytes;\n    };\n\n    if (this._cursor != 0) {\n      this.newline();\n    }\n\n    /* Encode images with ESC * */\n\n    if (this._options.imageMode == \"column\") {\n      this._queue([0x1b, 0x33, 0x24]);\n\n      getColumnData(width, height).forEach((bytes) => {\n        this._queue([\n          0x1b,\n          0x2a,\n          0x21,\n          width & 0xff,\n          (width >> 8) & 0xff,\n          bytes,\n          0x0a,\n        ]);\n      });\n\n      this._queue([0x1b, 0x32]);\n    }\n\n    /* Encode images with GS v */\n\n    if (this._options.imageMode == \"raster\") {\n      this._queue([\n        0x1d,\n        0x76,\n        0x30,\n        0x00,\n        (width >> 3) & 0xff,\n        ((width >> 3) >> 8) & 0xff,\n        height & 0xff,\n        (height >> 8) & 0xff,\n        getRowData(width, height),\n      ]);\n    }\n\n    this._flush();\n\n    return this;\n  }\n\n  /**\n   * Cut paper\n   *\n   * @param  {string}          value   full or partial. When not specified a full cut will be assumed\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  cut(value) {\n    if (this._embedded) {\n      throw new Error(\"Cut is not supported in table cells or boxes\");\n    }\n\n    let data = 0x00;\n\n    if (value == \"partial\") {\n      data = 0x01;\n    }\n\n    this._queue([0x1d, 0x56, data]);\n\n    return this;\n  }\n\n  /**\n   * Pulse\n   *\n   * @param  {number}          device  0 or 1 for on which pin the device is connected, default of 0\n   * @param  {number}          on      Time the pulse is on in milliseconds, default of 100\n   * @param  {number}          off     Time the pulse is off in milliseconds, default of 500\n   * @return {object}                  Return the object, for easy chaining commands\n   *\n   */\n  pulse(device, on, off) {\n    if (this._embedded) {\n      throw new Error(\"Pulse is not supported in table cells or boxes\");\n    }\n\n    if (typeof device === \"undefined\") {\n      device = 0;\n    }\n\n    if (typeof on === \"undefined\") {\n      on = 100;\n    }\n\n    if (typeof off === \"undefined\") {\n      off = 500;\n    }\n\n    on = Math.min(500, Math.round(on / 2));\n    off = Math.min(500, Math.round(off / 2));\n\n    this._queue([0x1b, 0x70, device ? 1 : 0, on & 0xff, off & 0xff]);\n\n    return this;\n  }\n\n  /**\n   * Add raw printer commands\n   *\n   * @param  {array}           data   raw bytes to be included\n   * @return {object}          Return the object, for easy chaining commands\n   *\n   */\n  raw(data) {\n    this._queue(data);\n\n    return this;\n  }\n\n  /**\n   * Encode all previous commands\n   *\n   * @return {Uint8Array}         Return the encoded bytes\n   *\n   */\n  encode() {\n    this._flush();\n\n    let length = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === \"number\") {\n        length++;\n      } else {\n        length += item.length;\n      }\n    });\n\n    const result = new Uint8Array(length);\n\n    let index = 0;\n\n    this._buffer.forEach((item) => {\n      if (typeof item === \"number\") {\n        result[index] = item;\n        index++;\n      } else {\n        result.set(item, index);\n        index += item.length;\n      }\n    });\n\n    this._reset();\n\n    return result;\n  }\n}\n\nexport default EscPosEncoder;\n"],"names":["$8b4a29098887679b$var$presetMap","html","skipScheme","lineBreakScheme","whitespace","$8b4a29098887679b$var$brPat","$8b4a29098887679b$var$lineBreakSchemeMap","unix","dos","mac","xhtml","$8b4a29098887679b$var$skipSchemeMap","bbcode","$8b4a29098887679b$var$modeMap","soft","hard","$8b4a29098887679b$var$wsMap","collapse","default","line","all","$8b4a29098887679b$var$rlbMap","multi","none","$8b4a29098887679b$var$rlbSMPat","$8b4a29098887679b$var$escapePat","$8b4a29098887679b$var$escapeRegExp","s","replace","$8b4a29098887679b$var$linewrap","start","stop","params","undefined","preset","skip","lineBreak","respectNum","preservedLineIndent","wrapLineIndent","wrapLineIndentBase","skipPat","lineBreakPat","lineBreakStr","multiLineBreakPat","wrapLineIndentPat","tabRepl","item","flags","i","mode","tabWidth","respectLineBreaks","preservedLinePrefix","wrapLineInitPrefix","Array","length","TypeError","Object","keys","join","parseInt","test","match","exec","isNaN","RegExp","global","ignoreCase","multiline","source","re","prefix","wsStrip","wsCollapse","wsLine","wsAll","tabPat","collapsePat","pPat","tPat","nonWsPat","wsPat","wrapLen","text","toString","lastIndex","blocks","mo","arr","b","res","j","k","segments","base","push","substring","index","type","breaks","remaining","bloc","value","chunks","segment","parts","split","acc","x","slice","concat","remnant","curLine","curLineLength","lines","bulge","cleanLine","preservedLine","wrapLinePrefix","finishOffCurLine","beforeHardBreak","idx","ln","rBase","str","search","chunk","chunk2","num","args","call","arguments","last","apply","wrap","shift","$8b4a29098887679b$export$2e2bcd8739ae039","$0a812cac8c47b3d2$export$2e2bcd8739ae039","grayscale","image","data","luminance","fill","threshold","bayer","thresholdMap","width","y","Math","floor","floydsteinberg","Uint8ClampedArray","height","l","error","atkinson","$090b3030c3e36709$export$2e2bcd8739ae039","flatten","background","alpha","invAlpha","$99e86369e1932b08$var$definitions","cp437","name","languages","offset","chars","cp720","cp737","cp775","cp850","cp851","cp852","cp853","cp855","cp857","cp858","cp860","cp861","cp862","cp863","cp864","cp865","cp866","cp869","cp874","cp1098","cp1118","cp1119","cp1125","cp1162","cp2001","cp3001","cp3002","cp3011","cp3012","cp3021","cp3041","cp3840","cp3841","cp3843","cp3844","cp3845","cp3846","cp3847","cp3848","iso88591","iso88592","iso88597","iso885915","rk1048","windows1250","windows1251","windows1252","windows1253","windows1254","windows1255","windows1256","windows1257","windows1258","$99e86369e1932b08$var$strings","en","jp","pt","fr","sv","dk","el","tr","ru","hu","pl","cz","ar","et","lt","bg","is","he","fa","uk","vi","kk","lv","mt","th","$99e86369e1932b08$export$2e2bcd8739ae039","static","codepage","map","language","string","input","output","Uint8Array","repeat","c","codepoint","codePointAt","position","indexOf","candidates","fragments","current","fragment","available","char","bytes","$c988ef698a1fe515$export$cd3d1f114b139967","assign","document","createElement","$4b75e4ef4fa4cda8$var$codepageMappings","epson","shiftjis","zjiang","bixolon","star","legacy","cp936","cp949","cp950","cp1252","iso88596","windows874","$4b75e4ef4fa4cda8$var$EscPosEncoder","constructor","options","this","_reset","_options","embedded","wordWrap","imageMode","codepageMapping","codepageCandidates","_embedded","_buffer","_queued","_cursor","_codepage","_state","align","bold","italic","underline","invert","_encode","encode","codepages","autoEncode","f","byteLength","buffer","set","_queue","forEach","_flush","indent","remainder","unshift","_wrap","w","_restoreState","_getCodepageIdentifier","initialize","supports","Error","newline","Number","size","alignments","left","center","right","table","columns","r","maxLines","cell","padStart","padEnd","columnEncoder","encoded","e","max","p","verticalAlign","marginLeft","raw","marginRight","rule","style","box","contents","elements","paddingLeft","paddingRight","barcode","symbology","symbologies","upca","upce","ean13","ean8","code39","coda39","itf","codabar","code93","code128","qrcode","model","errorlevel","models","errorlevels","m","q","h","element","algorithm","context","getContext","drawImage","getImageData","getPixel","ceil","getColumnData","getRowData","cut","pulse","device","on","off","min","round","result","$4b75e4ef4fa4cda8$export$2e2bcd8739ae039"],"version":3,"file":"module.js.map"}